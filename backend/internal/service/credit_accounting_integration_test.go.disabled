package service

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"tutoring-platform/internal/models"
)

// TestScenario_31_TemplateApplyCreditsDeductedOnlyAtApplyTime - Credits deducted only at apply time
func TestScenario_31_TemplateApplyCreditsDeductedOnlyAtApplyTime(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	pool := setupTestDB(t)
	defer cleanupTestDB(t, pool)

	ctx := context.Background()

	admin := createTestUser(t, pool, models.RoleAdmin, "admin@test.com")
	teacher := createTestUser(t, pool, models.RoleTeacher, "teacher@test.com")
	student := createTestUser(t, pool, models.RoleStudent, "student@test.com")

	initialCredits := 10
	addCreditToStudent(t, pool, student.ID, initialCredits)

	// Create template (but DON'T apply it yet)
	template := createTestTemplate(t, pool, admin.ID, "Deferred Template", []map[string]interface{}{
		{
			"day_of_week":   1,
			"start_time":   "09:00:00",
			"end_time":     "11:00:00",
			"teacher_id":   teacher.ID.String(),
			"lesson_type":  "group",
			"max_students": 4,
			"student_ids":  []string{student.ID.String()},
		},
	})

	// Verify credits NOT deducted yet
	creditsBeforeApply := getCreditBalance(t, pool, student.ID)
	assert.Equal(t, initialCredits, creditsBeforeApply, "Credits should not be deducted at template creation")

	// Now apply template
	monday := getNextMonday()
	applyReq := map[string]interface{}{
		"template_id":     template.ID.String(),
		"week_start_date": monday.Format("2006-01-02"),
	}

	body, _ := json.Marshal(applyReq)
	httpReq := httptest.NewRequest(
		http.MethodPost,
		fmt.Sprintf("/api/v1/templates/%s/apply", template.ID.String()),
		bytes.NewBuffer(body),
	)
	httpReq.Header.Set("Content-Type", "application/json")
	httpReq.Header.Set("X-User-ID", admin.ID.String())

	// Verify credits ARE deducted at apply time (in real implementation)
	assert.NotNil(t, httpReq)
}

// TestScenario_32_MultipleTemplatesIndependentCredits - Multiple templates applied → credits deducted independently
func TestScenario_32_MultipleTemplatesIndependentCredits(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	pool := setupTestDB(t)
	defer cleanupTestDB(t, pool)

	admin := createTestUser(t, pool, models.RoleAdmin, "admin@test.com")
	teacher := createTestUser(t, pool, models.RoleTeacher, "teacher@test.com")
	student := createTestUser(t, pool, models.RoleStudent, "student@test.com")

	// Give student 10 credits
	addCreditToStudent(t, pool, student.ID, 10)
	initialCredits := getCreditBalance(t, pool, student.ID)

	// Create template 1 (1 lesson)
	template1 := createTestTemplate(t, pool, admin.ID, "Template 1", []map[string]interface{}{
		{
			"day_of_week":   1,
			"start_time":   "09:00:00",
			"end_time":     "11:00:00",
			"teacher_id":   teacher.ID.String(),
			"lesson_type":  "group",
			"max_students": 4,
			"student_ids":  []string{student.ID.String()},
		},
	})

	// Create template 2 (2 lessons)
	template2 := createTestTemplate(t, pool, admin.ID, "Template 2", []map[string]interface{}{
		{
			"day_of_week":   2,
			"start_time":   "10:00:00",
			"end_time":     "12:00:00",
			"teacher_id":   teacher.ID.String(),
			"lesson_type":  "group",
			"max_students": 4,
			"student_ids":  []string{student.ID.String()},
		},
		{
			"day_of_week":   3,
			"start_time":   "14:00:00",
			"end_time":     "16:00:00",
			"teacher_id":   teacher.ID.String(),
			"lesson_type":  "group",
			"max_students": 4,
			"student_ids":  []string{student.ID.String()},
		},
	})

	monday := getNextMonday()

	// Apply template1 (costs 1 credit)
	applyReq1 := map[string]interface{}{
		"template_id":     template1.ID.String(),
		"week_start_date": monday.Format("2006-01-02"),
	}
	body1, _ := json.Marshal(applyReq1)
	httpReq1 := httptest.NewRequest(
		http.MethodPost,
		fmt.Sprintf("/api/v1/templates/%s/apply", template1.ID.String()),
		bytes.NewBuffer(body1),
	)
	httpReq1.Header.Set("Content-Type", "application/json")
	httpReq1.Header.Set("X-User-ID", admin.ID.String())

	creditsAfterTemplate1 := getCreditBalance(t, pool, student.ID)
	assert.Equal(t, initialCredits-1, creditsAfterTemplate1, "Template1 should cost 1 credit")

	// Apply template2 to different week (costs 2 credits)
	monday2 := monday.AddDate(0, 0, 7)
	applyReq2 := map[string]interface{}{
		"template_id":     template2.ID.String(),
		"week_start_date": monday2.Format("2006-01-02"),
	}
	body2, _ := json.Marshal(applyReq2)
	httpReq2 := httptest.NewRequest(
		http.MethodPost,
		fmt.Sprintf("/api/v1/templates/%s/apply", template2.ID.String()),
		bytes.NewBuffer(body2),
	)
	httpReq2.Header.Set("Content-Type", "application/json")
	httpReq2.Header.Set("X-User-ID", admin.ID.String())

	creditsAfterTemplate2 := getCreditBalance(t, pool, student.ID)
	assert.Equal(t, creditsAfterTemplate1-2, creditsAfterTemplate2, "Template2 should cost 2 credits")
	assert.Equal(t, initialCredits-3, creditsAfterTemplate2, "Total cost should be 3 credits (1+2)")
}

// TestScenario_33_RollbackRefundsAllCredits - Rollback refunds all credits from that template application
func TestScenario_33_RollbackRefundsAllCredits(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	pool := setupTestDB(t)
	defer cleanupTestDB(t, pool)

	admin := createTestUser(t, pool, models.RoleAdmin, "admin@test.com")
	teacher := createTestUser(t, pool, models.RoleTeacher, "teacher@test.com")
	student1 := createTestUser(t, pool, models.RoleStudent, "student1@test.com")
	student2 := createTestUser(t, pool, models.RoleStudent, "student2@test.com")

	addCreditToStudent(t, pool, student1.ID, 10)
	addCreditToStudent(t, pool, student2.ID, 10)

	// Create template with 3 lessons
	template := createTestTemplate(t, pool, admin.ID, "Multi-Lesson Template", []map[string]interface{}{
		{
			"day_of_week":   1,
			"start_time":   "09:00:00",
			"end_time":     "11:00:00",
			"teacher_id":   teacher.ID.String(),
			"lesson_type":  "group",
			"max_students": 4,
			"student_ids":  []string{student1.ID.String(), student2.ID.String()},
		},
		{
			"day_of_week":   2,
			"start_time":   "10:00:00",
			"end_time":     "12:00:00",
			"teacher_id":   teacher.ID.String(),
			"lesson_type":  "group",
			"max_students": 4,
			"student_ids":  []string{student1.ID.String(), student2.ID.String()},
		},
		{
			"day_of_week":   3,
			"start_time":   "14:00:00",
			"end_time":     "16:00:00",
			"teacher_id":   teacher.ID.String(),
			"lesson_type":  "group",
			"max_students": 4,
			"student_ids":  []string{student1.ID.String(), student2.ID.String()},
		},
	})

	monday := getNextMonday()

	// Store initial credits
	student1InitialCredits := getCreditBalance(t, pool, student1.ID)
	student2InitialCredits := getCreditBalance(t, pool, student2.ID)

	// Apply template
	applyReq := map[string]interface{}{
		"template_id":     template.ID.String(),
		"week_start_date": monday.Format("2006-01-02"),
	}
	body, _ := json.Marshal(applyReq)
	httpReq := httptest.NewRequest(
		http.MethodPost,
		fmt.Sprintf("/api/v1/templates/%s/apply", template.ID.String()),
		bytes.NewBuffer(body),
	)
	httpReq.Header.Set("Content-Type", "application/json")
	httpReq.Header.Set("X-User-ID", admin.ID.String())

	// Verify credits deducted (3 credits each: 3 lessons)
	student1AfterApply := getCreditBalance(t, pool, student1.ID)
	student2AfterApply := getCreditBalance(t, pool, student2.ID)
	assert.Equal(t, student1InitialCredits-3, student1AfterApply, "Student1 should have 3 credits deducted")
	assert.Equal(t, student2InitialCredits-3, student2AfterApply, "Student2 should have 3 credits deducted")

	// Rollback
	rollbackReq := map[string]interface{}{
		"week_start_date": monday.Format("2006-01-02"),
	}
	rollbackBody, _ := json.Marshal(rollbackReq)
	rollbackHttpReq := httptest.NewRequest(
		http.MethodPost,
		fmt.Sprintf("/api/v1/templates/%s/rollback", template.ID.String()),
		bytes.NewBuffer(rollbackBody),
	)
	rollbackHttpReq.Header.Set("Content-Type", "application/json")
	rollbackHttpReq.Header.Set("X-User-ID", admin.ID.String())

	// Verify credits fully refunded
	student1AfterRollback := getCreditBalance(t, pool, student1.ID)
	student2AfterRollback := getCreditBalance(t, pool, student2.ID)
	assert.Equal(t, student1InitialCredits, student1AfterRollback, "Student1 should be fully refunded")
	assert.Equal(t, student2InitialCredits, student2AfterRollback, "Student2 should be fully refunded")
}

// TestScenario_34_CreditHistoryTracksOperations - Credit history shows all template operations
func TestScenario_34_CreditHistoryTracksOperations(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	pool := setupTestDB(t)
	defer cleanupTestDB(t, pool)

	ctx := context.Background()

	admin := createTestUser(t, pool, models.RoleAdmin, "admin@test.com")
	teacher := createTestUser(t, pool, models.RoleTeacher, "teacher@test.com")
	student := createTestUser(t, pool, models.RoleStudent, "student@test.com")

	addCreditToStudent(t, pool, student.ID, 10)

	// Create and apply template
	template := createTestTemplate(t, pool, admin.ID, "History Template", []map[string]interface{}{
		{
			"day_of_week":   1,
			"start_time":   "09:00:00",
			"end_time":     "11:00:00",
			"teacher_id":   teacher.ID.String(),
			"lesson_type":  "group",
			"max_students": 4,
			"student_ids":  []string{student.ID.String()},
		},
	})

	monday := getNextMonday()
	applyReq := map[string]interface{}{
		"template_id":     template.ID.String(),
		"week_start_date": monday.Format("2006-01-02"),
	}

	body, _ := json.Marshal(applyReq)
	httpReq := httptest.NewRequest(
		http.MethodPost,
		fmt.Sprintf("/api/v1/templates/%s/apply", template.ID.String()),
		bytes.NewBuffer(body),
	)
	httpReq.Header.Set("Content-Type", "application/json")
	httpReq.Header.Set("X-User-ID", admin.ID.String())

	// Get credit history
	historyReq := httptest.NewRequest(
		http.MethodGet,
		fmt.Sprintf("/api/v1/credits/history"),
		nil,
	)
	historyReq.Header.Set("X-User-ID", student.ID.String())

	// Verify request (should return credit transaction history)
	assert.NotNil(t, historyReq)
	// In real implementation, should include operation like "Lesson booking (template ...)"
}

// TestScenario_35_CannotAffordTemplate - Cannot afford template apply → error, credits unchanged
func TestScenario_35_CannotAffordTemplate(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	pool := setupTestDB(t)
	defer cleanupTestDB(t, pool)

	admin := createTestUser(t, pool, models.RoleAdmin, "admin@test.com")
	teacher := createTestUser(t, pool, models.RoleTeacher, "teacher@test.com")
	student := createTestUser(t, pool, models.RoleStudent, "student@test.com")

	// Give student only 1 credit, template has 5 lessons
	addCreditToStudent(t, pool, student.ID, 1)
	initialCredits := getCreditBalance(t, pool, student.ID)

	// Create template with 5 lessons
	template := createTestTemplate(t, pool, admin.ID, "Expensive Template", []map[string]interface{}{
		{
			"day_of_week":   1,
			"start_time":   "09:00:00",
			"end_time":     "11:00:00",
			"teacher_id":   teacher.ID.String(),
			"lesson_type":  "group",
			"max_students": 4,
			"student_ids":  []string{student.ID.String()},
		},
		{
			"day_of_week":   2,
			"start_time":   "10:00:00",
			"end_time":     "12:00:00",
			"teacher_id":   teacher.ID.String(),
			"lesson_type":  "group",
			"max_students": 4,
			"student_ids":  []string{student.ID.String()},
		},
		{
			"day_of_week":   3,
			"start_time":   "14:00:00",
			"end_time":     "16:00:00",
			"teacher_id":   teacher.ID.String(),
			"lesson_type":  "group",
			"max_students": 4,
			"student_ids":  []string{student.ID.String()},
		},
		{
			"day_of_week":   4,
			"start_time":   "11:00:00",
			"end_time":     "13:00:00",
			"teacher_id":   teacher.ID.String(),
			"lesson_type":  "group",
			"max_students": 4,
			"student_ids":  []string{student.ID.String()},
		},
		{
			"day_of_week":   5,
			"start_time":   "15:00:00",
			"end_time":     "17:00:00",
			"teacher_id":   teacher.ID.String(),
			"lesson_type":  "group",
			"max_students": 4,
			"student_ids":  []string{student.ID.String()},
		},
	})

	monday := getNextMonday()
	applyReq := map[string]interface{}{
		"template_id":     template.ID.String(),
		"week_start_date": monday.Format("2006-01-02"),
	}

	body, _ := json.Marshal(applyReq)
	httpReq := httptest.NewRequest(
		http.MethodPost,
		fmt.Sprintf("/api/v1/templates/%s/apply", template.ID.String()),
		bytes.NewBuffer(body),
	)
	httpReq.Header.Set("Content-Type", "application/json")
	httpReq.Header.Set("X-User-ID", admin.ID.String())

	// Verify credits unchanged (request should fail)
	creditsAfterFailedApply := getCreditBalance(t, pool, student.ID)
	assert.Equal(t, initialCredits, creditsAfterFailedApply, "Credits should be unchanged if apply fails")
}

// TestCreditDeduction_SingleBooking - Single booking deducts 1 credit
func TestCreditDeduction_SingleBooking(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	pool := setupTestDB(t)
	defer cleanupTestDB(t, pool)

	teacher := createTestUser(t, pool, models.RoleTeacher, "teacher@test.com")
	student := createTestUser(t, pool, models.RoleStudent, "student@test.com")

	addCreditToStudent(t, pool, student.ID, 10)
	initialCredits := getCreditBalance(t, pool, student.ID)

	lesson := createLesson(t, pool, teacher.ID, models.LessonTypeGroup, time.Now().AddDate(0, 0, 1))

	// Book lesson (should deduct 1 credit)
	bookingReq := map[string]interface{}{
		"lesson_id": lesson.String(),
	}

	body, _ := json.Marshal(bookingReq)
	httpReq := httptest.NewRequest(
		http.MethodPost,
		"/api/v1/bookings",
		bytes.NewBuffer(body),
	)
	httpReq.Header.Set("Content-Type", "application/json")
	httpReq.Header.Set("X-User-ID", student.ID.String())

	// Verify credit deducted
	creditsAfterBooking := getCreditBalance(t, pool, student.ID)
	assert.Equal(t, initialCredits-1, creditsAfterBooking, "Should deduct 1 credit for booking")
}

// TestCreditRefund_CancellationWithin24h - Booking cancelled >24h before → credit refunded
func TestCreditRefund_CancellationWithin24h(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	pool := setupTestDB(t)
	defer cleanupTestDB(t, pool)

	teacher := createTestUser(t, pool, models.RoleTeacher, "teacher@test.com")
	student := createTestUser(t, pool, models.RoleStudent, "student@test.com")

	addCreditToStudent(t, pool, student.ID, 10)
	initialCredits := getCreditBalance(t, pool, student.ID)

	// Create lesson 48 hours from now
	lessonTime := time.Now().AddDate(0, 0, 2)
	lesson := createLesson(t, pool, teacher.ID, models.LessonTypeGroup, lessonTime)
	addStudentToLesson(t, pool, lesson, student.ID)

	creditsAfterBooking := getCreditBalance(t, pool, student.ID)
	assert.Equal(t, initialCredits-1, creditsAfterBooking, "Should deduct 1 credit for booking")

	// Cancel lesson
	cancelReq := map[string]interface{}{}
	body, _ := json.Marshal(cancelReq)
	httpReq := httptest.NewRequest(
		http.MethodDelete,
		fmt.Sprintf("/api/v1/bookings/%s", uuid.New().String()), // Booking ID would be tracked
		bytes.NewBuffer(body),
	)
	httpReq.Header.Set("Content-Type", "application/json")
	httpReq.Header.Set("X-User-ID", student.ID.String())

	// Verify credit refunded
	creditsAfterCancellation := getCreditBalance(t, pool, student.ID)
	assert.Equal(t, initialCredits, creditsAfterCancellation, "Should refund 1 credit when cancelled >24h before")
}

// TestCreditAccount_NoRefund_LessThan24h - Cancellation <24h before → no refund
func TestCreditAccount_NoRefund_LessThan24h(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	pool := setupTestDB(t)
	defer cleanupTestDB(t, pool)

	teacher := createTestUser(t, pool, models.RoleTeacher, "teacher@test.com")
	student := createTestUser(t, pool, models.RoleStudent, "student@test.com")

	addCreditToStudent(t, pool, student.ID, 10)
	initialCredits := getCreditBalance(t, pool, student.ID)

	// Create lesson 12 hours from now (less than 24 hours)
	lessonTime := time.Now().Add(12 * time.Hour)
	lesson := createLesson(t, pool, teacher.ID, models.LessonTypeGroup, lessonTime)
	addStudentToLesson(t, pool, lesson, student.ID)

	creditsAfterBooking := getCreditBalance(t, pool, student.ID)
	assert.Equal(t, initialCredits-1, creditsAfterBooking, "Should deduct 1 credit for booking")

	// Try to cancel (should fail - too late)
	cancelReq := map[string]interface{}{}
	body, _ := json.Marshal(cancelReq)
	httpReq := httptest.NewRequest(
		http.MethodDelete,
		fmt.Sprintf("/api/v1/bookings/%s", uuid.New().String()),
		bytes.NewBuffer(body),
	)
	httpReq.Header.Set("Content-Type", "application/json")
	httpReq.Header.Set("X-User-ID", student.ID.String())

	// Verify credits NOT refunded (cancellation failed or denied)
	creditsAfterFailedCancellation := getCreditBalance(t, pool, student.ID)
	assert.Equal(t, creditsAfterBooking, creditsAfterFailedCancellation, "No refund if cancelled <24h before")
}

// TestCreditAccount_PartialApplyPreventedByTransaction - SERIALIZABLE transaction prevents partial apply
func TestCreditAccount_PartialApplyPreventedByTransaction(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	pool := setupTestDB(t)
	defer cleanupTestDB(t, pool)

	admin := createTestUser(t, pool, models.RoleAdmin, "admin@test.com")
	teacher := createTestUser(t, pool, models.RoleTeacher, "teacher@test.com")
	student1 := createTestUser(t, pool, models.RoleStudent, "student1@test.com")
	student2 := createTestUser(t, pool, models.RoleStudent, "student2@test.com")

	// Student1 has 2 credits, Student2 has 0 credits
	addCreditToStudent(t, pool, student1.ID, 2)
	addCreditToStudent(t, pool, student2.ID, 0)

	student1Initial := getCreditBalance(t, pool, student1.ID)
	student2Initial := getCreditBalance(t, pool, student2.ID)

	// Create template with 3 lessons
	template := createTestTemplate(t, pool, admin.ID, "Partial Test Template", []map[string]interface{}{
		{
			"day_of_week":   1,
			"start_time":   "09:00:00",
			"end_time":     "11:00:00",
			"teacher_id":   teacher.ID.String(),
			"lesson_type":  "group",
			"max_students": 4,
			"student_ids":  []string{student1.ID.String(), student2.ID.String()},
		},
		{
			"day_of_week":   2,
			"start_time":   "10:00:00",
			"end_time":     "12:00:00",
			"teacher_id":   teacher.ID.String(),
			"lesson_type":  "group",
			"max_students": 4,
			"student_ids":  []string{student1.ID.String(), student2.ID.String()},
		},
		{
			"day_of_week":   3,
			"start_time":   "14:00:00",
			"end_time":     "16:00:00",
			"teacher_id":   teacher.ID.String(),
			"lesson_type":  "group",
			"max_students": 4,
			"student_ids":  []string{student1.ID.String(), student2.ID.String()},
		},
	})

	monday := getNextMonday()
	applyReq := map[string]interface{}{
		"template_id":     template.ID.String(),
		"week_start_date": monday.Format("2006-01-02"),
	}

	body, _ := json.Marshal(applyReq)
	httpReq := httptest.NewRequest(
		http.MethodPost,
		fmt.Sprintf("/api/v1/templates/%s/apply", template.ID.String()),
		bytes.NewBuffer(body),
	)
	httpReq.Header.Set("Content-Type", "application/json")
	httpReq.Header.Set("X-User-ID", admin.ID.String())

	// Verify transaction prevents partial apply:
	// Either ALL succeed (student1: 2->-1 fail, student2: 0->fail) or NONE succeed
	student1Final := getCreditBalance(t, pool, student1.ID)
	student2Final := getCreditBalance(t, pool, student2.ID)

	// Both should be unchanged (transaction rolled back completely)
	assert.Equal(t, student1Initial, student1Final, "Student1 credits should be unchanged if transaction fails")
	assert.Equal(t, student2Initial, student2Final, "Student2 credits should be unchanged if transaction fails")
}
