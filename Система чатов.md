# Техническая спецификация: Система чатов для репетиторской школы

## Описание системы простыми словами

Ученики и преподаватели могут переписываться друг с другом. Админ видит все чаты в режиме "только чтение".

**Главный принцип:** После того как ученик прошёл занятие с преподавателем, между ними автоматически создаётся чат. Один чат на пару - если они проходят 10 занятий, чат всё равно один и тот же.

**Как работают сообщения:**
- Сообщения ВСЕГДА сохраняются в базу данных
- Если получатель онлайн - он сразу видит сообщение через SSE
- Если получатель офлайн - при следующем заходе загрузит все сообщения из БД
- Сообщения никогда не теряются

---

## Технологический стек

- **Backend:** Go (Golang)
- **Frontend:** React
- **База данных:** PostgreSQL
- **Real-time:** Server-Sent Events (SSE)
- **API:** REST + SSE

---

## База данных

### Таблица: users

Все пользователи системы.
```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    name VARCHAR(255) NOT NULL,
    role VARCHAR(20) NOT NULL, -- 'student', 'teacher', 'admin'
    created_at TIMESTAMP DEFAULT NOW()
);
```

### Таблица: lessons

Занятия между учеником и преподавателем.
```sql
CREATE TABLE lessons (
    id SERIAL PRIMARY KEY,
    teacher_id INT REFERENCES users(id),
    student_id INT REFERENCES users(id),
    scheduled_at TIMESTAMP NOT NULL,
    status VARCHAR(20) NOT NULL, -- 'scheduled', 'completed', 'cancelled'
    completed_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_lessons_teacher_student ON lessons(teacher_id, student_id);
CREATE INDEX idx_lessons_status ON lessons(status);
```

**Зачем нужна:** Когда статус занятия меняется на `completed`, автоматически создаётся чат между учеником и преподавателем.

### Таблица: chats

Комнаты для переписки.
```sql
CREATE TABLE chats (
    id SERIAL PRIMARY KEY,
    created_at TIMESTAMP DEFAULT NOW()
);
```

**Правило:** Один чат на пару "ученик-преподаватель". Создаётся один раз, используется всегда.

### Таблица: chat_participants

Кто участвует в каком чате (связь многие-ко-многим).
```sql
CREATE TABLE chat_participants (
    id SERIAL PRIMARY KEY,
    chat_id INT REFERENCES chats(id) ON DELETE CASCADE,
    user_id INT REFERENCES users(id) ON DELETE CASCADE,
    role VARCHAR(20) NOT NULL, -- 'student' или 'teacher'
    joined_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(chat_id, user_id) -- один пользователь не может быть дважды в одном чате
);

CREATE INDEX idx_participants_user ON chat_participants(user_id);
CREATE INDEX idx_participants_chat ON chat_participants(chat_id);
```

**Назначение:** Определяет кто может писать и читать сообщения в чате.

### Таблица: messages

Все сообщения.
```sql
CREATE TABLE messages (
    id SERIAL PRIMARY KEY,
    chat_id INT REFERENCES chats(id) ON DELETE CASCADE,
    sender_id INT REFERENCES users(id),
    content TEXT NOT NULL,
    is_deleted BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_messages_chat_time ON messages(chat_id, created_at DESC);
CREATE INDEX idx_messages_sender ON messages(sender_id);
```

**Важно:** 
- Сообщения НИКОГДА не удаляются физически
- При удалении ставится `is_deleted = TRUE`
- Это нужно для истории и аудита

---

## Логика создания чатов

### Когда создаётся чат?

После завершения любого занятия между учеником и преподавателем.

### Как это работает?

**Вариант 1: Триггер в БД (рекомендуется)**
```sql
CREATE OR REPLACE FUNCTION create_chat_after_lesson()
RETURNS TRIGGER AS $$
DECLARE
    existing_chat_id INT;
BEGIN
    -- Проверяем только если занятие завершено
    IF NEW.status = 'completed' AND OLD.status != 'completed' THEN
        
        -- Ищем существующий чат между этими двумя пользователями
        SELECT c.id INTO existing_chat_id
        FROM chats c
        INNER JOIN chat_participants cp1 ON c.id = cp1.chat_id
        INNER JOIN chat_participants cp2 ON c.id = cp2.chat_id
        WHERE cp1.user_id = NEW.teacher_id
          AND cp2.user_id = NEW.student_id;
        
        -- Если чата нет - создаём
        IF existing_chat_id IS NULL THEN
            INSERT INTO chats DEFAULT VALUES
            RETURNING id INTO existing_chat_id;
            
            -- Добавляем двух участников
            INSERT INTO chat_participants (chat_id, user_id, role)
            VALUES 
                (existing_chat_id, NEW.teacher_id, 'teacher'),
                (existing_chat_id, NEW.student_id, 'student');
        END IF;
        
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER lesson_completed_trigger
AFTER UPDATE ON lessons
FOR EACH ROW
EXECUTE FUNCTION create_chat_after_lesson();
```

**Вариант 2: В коде Go (альтернатива)**

После обновления статуса занятия на `completed` вызвать функцию:
```go
// Псевдокод
func CreateChatIfNeeded(teacherID, studentID int) error {
    // 1. Проверить существует ли чат
    chatID := FindChatBetween(teacherID, studentID)
    
    // 2. Если нет - создать
    if chatID == 0 {
        chatID = CreateChat()
        AddParticipant(chatID, teacherID, "teacher")
        AddParticipant(chatID, studentID, "student")
    }
    
    return nil
}
```

**Рекомендация:** Используй триггер в БД - меньше шансов забыть вызвать функцию в коде.

---

## REST API

### 1. Получить список чатов

**Endpoint:** `GET /api/chats`

**Кто может:** Student, Teacher (свои чаты), Admin (все чаты через `/api/admin/chats`)

**Ответ для Student/Teacher:**
```json
{
  "chats": [
    {
      "id": 123,
      "participant": {
        "id": 456,
        "name": "Иван Петров",
        "role": "teacher"
      },
      "last_message": {
        "content": "Домашнее задание на завтра",
        "created_at": "2025-01-17T15:30:00Z"
      },
      "unread_count": 3
    }
  ]
}
```

**Логика на backend:**
```
1. Получить user_id из JWT токена
2. Найти все чаты где пользователь участник:
   SELECT c.id, c.created_at 
   FROM chats c
   INNER JOIN chat_participants cp ON c.id = cp.chat_id
   WHERE cp.user_id = ?
3. Для каждого чата:
   - Найти второго участника (собеседника)
   - Найти последнее сообщение
   - Посчитать непрочитанные (сообщения created_at > last_visit)
4. Вернуть список
```

**Ответ для Admin (`GET /api/admin/chats`):**
```json
{
  "chats": [
    {
      "id": 123,
      "participants": [
        {"id": 1, "name": "Ученик Иванов", "role": "student"},
        {"id": 2, "name": "Препод Петров", "role": "teacher"}
      ],
      "messages_count": 45,
      "last_message_at": "2025-01-17T15:30:00Z"
    }
  ]
}
```

---

### 2. Получить историю сообщений

**Endpoint:** `GET /api/chats/{chat_id}/messages`

**Параметры:**
- `limit` (default: 50) - сколько сообщений вернуть
- `before_id` (optional) - ID сообщения, до которого загрузить (для пагинации)

**Пример:** `GET /api/chats/123/messages?limit=50&before_id=999`

**Ответ:**
```json
{
  "messages": [
    {
      "id": 998,
      "sender_id": 456,
      "content": "Привет!",
      "is_deleted": false,
      "created_at": "2025-01-17T15:25:00Z"
    },
    {
      "id": 997,
      "sender_id": 789,
      "content": "Добрый день",
      "is_deleted": false,
      "created_at": "2025-01-17T15:20:00Z"
    }
  ],
  "has_more": true
}
```

**Логика на backend:**
```
1. Получить user_id из JWT токена
2. Проверить доступ:
   - Если role = admin → разрешить
   - Иначе проверить участие:
     SELECT 1 FROM chat_participants 
     WHERE chat_id = ? AND user_id = ?
   - Если нет записи → 403 Forbidden
3. Загрузить сообщения:
   SELECT * FROM messages
   WHERE chat_id = ?
     AND (before_id IS NULL OR id < before_id)
     AND is_deleted = FALSE
   ORDER BY created_at DESC
   LIMIT ?
4. Вернуть в хронологическом порядке (развернуть массив)
```

**Пагинация:**
- Первый запрос: `GET /api/chats/123/messages?limit=50` - последние 50
- Прокрутили вверх, нужны старые: `GET /api/chats/123/messages?limit=50&before_id=950`

---

### 3. Отправить сообщение

**Endpoint:** `POST /api/messages`

**Тело запроса:**
```json
{
  "chat_id": 123,
  "content": "Текст сообщения"
}
```

**Ответ:**
```json
{
  "id": 1000,
  "chat_id": 123,
  "sender_id": 456,
  "content": "Текст сообщения",
  "is_deleted": false,
  "created_at": "2025-01-17T15:35:00Z"
}
```

**Логика на backend:**
```
1. Получить user_id из JWT токена
2. Проверить участие в чате (как в п.2)
3. Проверить что role != admin (админы не могут писать)
4. Валидация:
   - content не пустой
   - content не длиннее 10000 символов
5. Сохранить в БД:
   INSERT INTO messages (chat_id, sender_id, content)
   VALUES (?, ?, ?)
6. Получить ID созданного сообщения
7. Найти получателей (других участников чата):
   SELECT user_id FROM chat_participants
   WHERE chat_id = ? AND user_id != ?
8. Для каждого получателя:
   - Проверить есть ли активное SSE соединение
   - Если есть → отправить событие "new_message"
9. Отправить событие админам (если они онлайн)
10. Вернуть созданное сообщение
```

---

### 4. Удалить сообщение

**Endpoint:** `DELETE /api/messages/{message_id}`

**Ответ:**
```json
{
  "success": true
}
```

**Логика на backend:**
```
1. Получить user_id из JWT токена
2. Найти сообщение:
   SELECT * FROM messages WHERE id = ?
3. Проверить что sender_id = user_id (только автор может удалить)
4. Установить флаг:
   UPDATE messages SET is_deleted = TRUE WHERE id = ?
5. Найти chat_id сообщения
6. Отправить SSE событие "message_deleted" всем участникам чата
7. Вернуть success
```

---

## Server-Sent Events (SSE)

### Что такое SSE простыми словами?

Представь что сервер открывает трубу к браузеру и может в любой момент отправить сообщение. Браузер просто слушает эту трубу.

**Обычный REST:**
```
Браузер: "Есть новые сообщения?"
Сервер: "Нет"
[3 секунды спустя]
Браузер: "Есть новые сообщения?"
Сервер: "Нет"
[3 секунды спустя]
Браузер: "Есть новые сообщения?"
Сервер: "Да, вот они"
```

**С SSE:**
```
Браузер: "Подключаюсь к трубе"
Сервер: "ОК, слушай"
[тишина... когда придёт сообщение]
Сервер: "Новое сообщение!"
Браузер: "Получил!"
```

Никакого опроса каждые 3 секунды. Сервер сам пушит когда есть что сказать.

---

### Как работает SSE на практике

**Endpoint:** `GET /api/events/chat`

**Заголовки ответа:**
```
HTTP/1.1 200 OK
Content-Type: text/event-stream
Cache-Control: no-cache
Connection: keep-alive
```

**Формат событий:**
```
event: new_message
data: {"chat_id":123,"message":{"id":1000,"sender_id":456,"content":"Привет","created_at":"2025-01-17T15:35:00Z"}}

event: message_deleted
data: {"chat_id":123,"message_id":999}
```

**Важно:** 
- Каждое событие - это строка `event: тип` и `data: JSON`
- После каждого события две пустые строки `\n\n`
- Соединение остаётся открытым постоянно

---

### Архитектура SSE на Backend (Go)

#### 1. Connection Manager

Это структура, которая хранит все активные SSE подключения.

**Что хранит:**
```go
type ConnectionManager struct {
    // Ключ - user_id, значение - список каналов для отправки событий
    connections map[int][]chan Event
    mu sync.RWMutex // для потокобезопасности
}
```

**Методы:**
```go
// Добавить новое подключение
AddConnection(userID int, eventChan chan Event)

// Удалить подключение (когда браузер отключился)
RemoveConnection(userID int, eventChan chan Event)

// Отправить событие конкретному пользователю
SendToUser(userID int, event Event)

// Отправить всем участникам чата
SendToChat(chatID int, event Event, excludeUserID int)
```

**Пример:**
```
connections = {
    123: [chan1, chan2],  // у пользователя 123 открыто 2 вкладки
    456: [chan3],          // у пользователя 456 одна вкладка
    789: []                // пользователь 789 офлайн
}
```

#### 2. SSE Handler

Обработчик HTTP запроса на `GET /api/events/chat`.

**Алгоритм:**
```
1. Получить user_id из JWT токена (из cookie или query параметра)
2. Создать новый канал для событий: eventChan := make(chan Event)
3. Добавить в Connection Manager: AddConnection(userID, eventChan)
4. Установить заголовки ответа (text/event-stream)
5. Запустить бесконечный цикл:
   - Ждать событие из канала: event := <-eventChan
   - Записать в HTTP response: "event: new_message\ndata: {json}\n\n"
   - Flush (отправить клиенту сразу)
6. Когда клиент отключается (браузер закрыл вкладку):
   - Удалить из Connection Manager: RemoveConnection(userID, eventChan)
   - Закрыть канал: close(eventChan)
```

**Псевдокод:**
```go
func SSEHandler(w http.ResponseWriter, r *http.Request) {
    userID := GetUserIDFromToken(r)
    
    // Создать канал для событий
    eventChan := make(chan Event, 10)
    
    // Добавить в менеджер
    connManager.AddConnection(userID, eventChan)
    defer connManager.RemoveConnection(userID, eventChan)
    
    // Установить заголовки
    w.Header().Set("Content-Type", "text/event-stream")
    w.Header().Set("Cache-Control", "no-cache")
    w.Header().Set("Connection", "keep-alive")
    
    // Слушать события
    for event := range eventChan {
        fmt.Fprintf(w, "event: %s\n", event.Type)
        fmt.Fprintf(w, "data: %s\n\n", event.DataJSON)
        w.(http.Flusher).Flush()
    }
}
```

#### 3. Event Broadcaster

Отправляет события всем нужным пользователям.

**Когда вызывается:** После сохранения нового сообщения в БД.

**Алгоритм:**
```
1. Получить chat_id из сообщения
2. Найти всех участников чата:
   SELECT user_id FROM chat_participants WHERE chat_id = ?
3. Для каждого участника (кроме отправителя):
   - connManager.SendToUser(userID, event)
4. Найти всех онлайн админов:
   SELECT user_id FROM users WHERE role = 'admin'
5. Для каждого админа:
   - connManager.SendToUser(adminID, event)
```

**Псевдокод:**
```go
func BroadcastNewMessage(message Message) {
    // Создать событие
    event := Event{
        Type: "new_message",
        Data: message,
    }
    
    // Найти участников
    participants := GetChatParticipants(message.ChatID)
    
    // Отправить всем кроме отправителя
    for _, userID := range participants {
        if userID != message.SenderID {
            connManager.SendToUser(userID, event)
        }
    }
    
    // Отправить админам
    admins := GetOnlineAdmins()
    for _, adminID := range admins {
        connManager.SendToUser(adminID, event)
    }
}
```

---

### Типы событий

#### new_message

Отправляется когда кто-то написал сообщение.
```json
{
  "type": "new_message",
  "data": {
    "chat_id": 123,
    "message": {
      "id": 1000,
      "sender_id": 456,
      "content": "Привет!",
      "created_at": "2025-01-17T15:35:00Z"
    }
  }
}
```

#### message_deleted

Отправляется когда кто-то удалил сообщение.
```json
{
  "type": "message_deleted",
  "data": {
    "chat_id": 123,
    "message_id": 999
  }
}
```

---

### Heartbeat (пинг соединения)

**Зачем нужен:** Прокси-серверы (nginx, облачные балансировщики) могут закрыть соединение если долго ничего не передаётся (обычно таймаут 60-90 секунд).

**Решение:** Каждые 30 секунд отправлять комментарий.

**Формат:**
```
: heartbeat
```

Строка начинающаяся с `:` - это комментарий в SSE. Браузер игнорирует, но соединение остаётся активным.

**Реализация в Go:**
```go
// В SSE Handler добавить goroutine
go func() {
    ticker := time.NewTicker(30 * time.Second)
    defer ticker.Stop()
    
    for {
        select {
        case <-ticker.C:
            fmt.Fprintf(w, ": heartbeat\n\n")
            w.(http.Flusher).Flush()
        case <-r.Context().Done():
            return // клиент отключился
        }
    }
}()
```

---

## Frontend (React)

### Подключение к SSE

**Библиотека:** Встроенный `EventSource` API.

**Код:**
```javascript
useEffect(() => {
  // Открыть соединение
  const eventSource = new EventSource('/api/events/chat', {
    withCredentials: true // отправлять cookies с JWT
  });
  
  // Подписаться на событие "new_message"
  eventSource.addEventListener('new_message', (e) => {
    const data = JSON.parse(e.data);
    
    // Добавить сообщение в state
    setMessages(prev => [...prev, data.message]);
  });
  
  // Подписаться на событие "message_deleted"
  eventSource.addEventListener('message_deleted', (e) => {
    const data = JSON.parse(e.data);
    
    // Удалить сообщение из state
    setMessages(prev => prev.filter(m => m.id !== data.message_id));
  });
  
  // Обработка ошибок
  eventSource.onerror = () => {
    console.log('SSE connection lost, will retry');
  };
  
  // Закрыть при размонтировании
  return () => {
    eventSource.close();
  };
}, []);
```

**Важно:** EventSource автоматически переподключается если соединение разорвалось.

---

### Загрузка истории сообщений

**Когда:** При открытии чата.

**Код:**
```javascript
useEffect(() => {
  if (currentChatId) {
    fetch(`/api/chats/${currentChatId}/messages?limit=50`)
      .then(res => res.json())
      .then(data => {
        setMessages(data.messages);
      });
  }
}, [currentChatId]);
```

---

### Отправка сообщения

**Код:**
```javascript
const sendMessage = async (content) => {
  // Оптимистично показать сразу (до ответа сервера)
  const tempMessage = {
    id: 'temp-' + Date.now(),
    sender_id: currentUserId,
    content: content,
    created_at: new Date().toISOString(),
    pending: true // флаг "отправляется"
  };
  
  setMessages(prev => [...prev, tempMessage]);
  
  // Отправить на сервер
  const response = await fetch('/api/messages', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      chat_id: currentChatId,
      content: content
    })
  });
  
  const savedMessage = await response.json();
  
  // Заменить временное сообщение на настоящее
  setMessages(prev => 
    prev.map(m => m.id === tempMessage.id ? savedMessage : m)
  );
};
```

**Почему оптимистичный UI?** Пользователь видит своё сообщение сразу, не ждёт ответа сервера.

---

### Пагинация (загрузка старых сообщений)

**Когда:** Пользователь прокрутил вверх до начала истории.

**Код:**
```javascript
const loadOlderMessages = async () => {
  const oldestMessageId = messages[0]?.id;
  
  const response = await fetch(
    `/api/chats/${currentChatId}/messages?limit=50&before_id=${oldestMessageId}`
  );
  
  const data = await response.json();
  
  // Добавить в начало массива
  setMessages(prev => [...data.messages, ...prev]);
};
```

---

## Авторизация

### JWT Token

**Как работает:**
1. Пользователь логинится → получает JWT token
2. Token сохраняется в HttpOnly cookie (безопасно от XSS)
3. При каждом запросе браузер автоматически отправляет cookie
4. Backend проверяет токен и извлекает user_id

**Для SSE:** 
EventSource автоматически отправляет cookies если указать `withCredentials: true`.

---

### Проверка доступа к чату

**Правило:** Пользователь может читать/писать только если он участник чата ИЛИ admin.

**Проверка:**
```sql
SELECT 1 FROM chat_participants 
WHERE chat_id = ? AND user_id = ?
```

Если вернулся результат → доступ есть.
Если пусто → проверить роль, если admin → разрешить, иначе 403.

---

## Роли пользователей

### Student (Ученик)

**Может:**
- Видеть свои чаты (с преподавателями)
- Читать историю сообщений
- Отправлять сообщения
- Удалять свои сообщения

**Не может:**
- Видеть чужие чаты
- Писать другим ученикам
- Писать в чат где не участник

### Teacher (Преподаватель)

**Может:** То же что и Student.

**Не может:** То же что и Student.

### Admin (Администратор)

**Может:**
- Видеть ВСЕ чаты системы
- Читать любой чат
- Получать SSE события из всех чатов

**Не может:**
- Отправлять сообщения (режим "только чтение")

**Особенность:** Админ НЕ добавляется в `chat_participants`. Доступ проверяется через роль.

---

## Полный flow отправки сообщения

### Шаг за шагом

1. **User печатает текст в React**
2. **User нажимает "Отправить"**
3. **React делает POST /api/messages**
```javascript
   fetch('/api/messages', {
     method: 'POST',
     body: JSON.stringify({ chat_id: 123, content: "Привет" })
   })
```
4. **Go backend получает запрос:**
   - Извлекает user_id из JWT: `456`
   - Проверяет участие в чате `123`
   - Проверяет что роль != admin
   - Валидирует content
5. **Go сохраняет в БД:**
```sql
   INSERT INTO messages (chat_id, sender_id, content)
   VALUES (123, 456, 'Привет')
   RETURNING id, created_at
```
   Получен id=1000, created_at=2025-01-17T15:35:00Z
6. **Go находит получателей:**
```sql
   SELECT user_id FROM chat_participants
   WHERE chat_id = 123 AND user_id != 456
```
   Результат: `[789]` (второй участник чата)
7. **Go проверяет: user 789 онлайн?**
```go
   connections[789] // есть канал? → онлайн
```
8. **Go отправляет SSE событие:**
```go
   event := Event{
     Type: "new_message",
     Data: {
       chat_id: 123,
       message: {id: 1000, sender_id: 456, content: "Привет", ...}
     }
   }
   connManager.SendToUser(789, event)
```
9. **React у получателя получает событие:**
```javascript
   eventSource.addEventListener('new_message', (e) => {
     const data = JSON.parse(e.data);
     setMessages(prev => [...prev, data.message]);
   });
```
10. **Сообщение появляется в UI получателя**

### Если получатель был офлайн?

1-6. Те же шаги
7. Go проверяет: user 789 онлайн? → НЕТ
8. Go ничего не делает (сообщение уже в БД)
9. Когда user 789 зайдёт:
   - Откроет чат
   - React загрузит историю: `GET /api/chats/123/messages`
   - Получит все сообщения включая "Привет"

**Вывод:** Сообщения ВСЕГДА сохраняются, SSE - это просто уведомление.

---

## Диаграмма архитектуры
```
┌─────────────┐
│   Browser   │
│   (React)   │
└──────┬──────┘
       │
       │ REST: POST /api/messages
       │ SSE: GET /api/events/chat
       │
┌──────▼──────────────────────────┐
│      Go Backend                 │
│                                 │
│  ┌─────────────────────────┐   │
│  │   REST Handlers         │   │
│  │  - GET /api/chats       │   │
│  │  - GET /api/messages    │   │
│  │  - POST /api/messages   │   │
│  │  - DELETE /api/messages │   │
│  └───────┬─────────────────┘   │
│          │                      │
│  ┌───────▼─────────────────┐   │
│  │  Connection Manager     │   │
│  │  map[userID][]chan      │   │
│  └───────┬─────────────────┘   │
│          │                      │
│  ┌───────▼─────────────────┐   │
│  │   SSE Handler           │   │
│  │  GET /api/events/chat   │   │
│  └─────────────────────────┘   │
└──────────┬──────────────────────┘
           │
           │ SQL queries
           │
┌──────────▼──────────────────────┐
│      PostgreSQL                 │
│                                 │
│  - users                        │
│  - lessons                      │
│  - chats                        │
│  - chat_participants            │
│  - messages                     │
└─────────────────────────────────┘
```

---

## Примеры кода

### Backend: Проверка доступа к чату
```go
func CheckChatAccess(userID, chatID int, userRole string) (bool, error) {
    // Админы видят всё
    if userRole == "admin" {
        return true, nil
    }
    
    // Проверяем участие
    var exists bool
    query := `
        SELECT EXISTS(
            SELECT 1 FROM chat_participants
            WHERE chat_id = $1 AND user_id = $2
        )
    `
    err := db.QueryRow(query, chatID, userID).Scan(&exists)
    
    return exists, err
}
```

### Backend: Отправка SSE события
```go
func (cm *ConnectionManager) SendToUser(userID int, event Event) {
    cm.mu.RLock()
    channels, exists := cm.connections[userID]
    cm.mu.RUnlock()
    
    if !exists {
        return // пользователь офлайн
    }
    
    // Отправить во все каналы (если несколько вкладок)
    for _, ch := range channels {
        select {
        case ch <- event:
            // отправлено
        default:
            // канал заполнен, пропускаем
        }
    }
}
```

### Frontend: Компонент чата
```javascript
function Chat({ chatId }) {
  const [messages, setMessages] = useState([]);
  const [inputText, setInputText] = useState('');
  
  // Загрузить историю при открытии
  useEffect(() => {
    fetch(`/api/chats/${chatId}/messages`)
      .then(res => res.json())
      .then(data => setMessages(data.messages));
  }, [chatId]);
  
  // Подключиться к SSE
  useEffect(() => {
    const eventSource = new EventSource('/api/events/chat', {
      withCredentials: true
    });
    
    eventSource.addEventListener('new_message', (e) => {
      const { chat_id, message } = JSON.parse(e.data);
      
      // Только если это наш чат
      if (chat_id === chatId) {
        setMessages(prev => [...prev, message]);
      }
    });
    
    return () => eventSource.close();
  }, [chatId]);
  
  // Отправить сообщение
  const handleSend = async () => {
    await fetch('/api/messages', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        chat_id: chatId,
        content: inputText
      })
    });
    
    setInputText('');
  };
  
  return (
    <div>
      <div className="messages">
        {messages.map(msg => (
          <div key={msg.id}>
            {msg.content}
          </div>
        ))}
      </div>
      
      <input
        value={inputText}
        onChange={e => setInputText(e.target.value)}
      />
      <button onClick={handleSend}>Отправить</button>
    </div>
  );
}
```

---

## Частые вопросы (FAQ)

### Пропадут ли сообщения если получатель офлайн?

**Нет.** Сообщения ВСЕГДА сохраняются в базу данных независимо от того, онлайн получатель или нет. SSE - это просто уведомление "обновись". Если уведомление не дошло - при следующем заходе пользователь загрузит историю через REST и увидит все пропущенные сообщения.

### Что если у пользователя открыто 2 вкладки?

Connection Manager хранит массив каналов на каждого пользователя. Событие отправится в оба канала. Оба окна получат уведомление. Это нормально.

### Может ли админ писать сообщения?

Нет. Админ видит чаты в режиме "только чтение". При попытке отправить сообщение backend вернёт ошибку.

### Как админ видит все чаты если он не участник?

Для админа есть отдельный endpoint `/api/admin/chats` который возвращает все чаты без проверки участия. Проверяется только роль пользователя.

### Что если SSE соединение разорвалось?

EventSource автоматически переподключается через ~3 секунды. После переподключения клиент может запросить последние сообщения через REST чтобы не пропустить ничего.

### Можно ли редактировать сообщения?

Нет, только удалять (мягкое удаление через флаг `is_deleted`).

### Сколько сообщений хранится в истории?

Все. Физически сообщения не удаляются (даже удалённые). Для очистки старых можно настроить автоматическое удаление сообщений старше N месяцев.

---

## Что нужно сделать разработчику

### 1. База данных
- Создать 5 таблиц (users, lessons, chats, chat_participants, messages)
- Создать индексы
- Создать триггер для автосоздания чатов после занятий

### 2. Backend (Go)
- REST handlers:
  - GET /api/chats (список чатов)
  - GET /api/chats/{id}/messages (история)
  - POST /api/messages (отправка)
  - DELETE /api/messages/{id} (удаление)
  - GET /api/admin/chats (для админов)
- SSE handler:
  - GET /api/events/chat (подключение к событиям)
- Connection Manager (хранение SSE соединений)
- Event Broadcaster (рассылка событий)
- Middleware для авторизации (JWT)

### 3. Frontend (React)
- Список чатов
- Интерфейс сообщений
- Подключение к SSE через EventSource
- Отправка сообщений через POST
- Удаление сообщений

### 4. Тестирование
- Создаётся ли чат после занятия?
- Могу ли я писать только в свои чаты?
- Приходят ли события через SSE?
- Загружаются ли старые сообщения при офлайне?

---

## Итого

**Что получится:**
- Ученик и преподаватель видят друг друга в чатах после первого занятия
- Могут переписываться в реальном времени (SSE)
- Сообщения сохраняются навсегда, ничего не теряется
- Админ видит все чаты для контроля
- Простая и надёжная архитектура на одном сервере

**Сложность реализации:** Средняя. Для джуниора 3-5 дней работы.
